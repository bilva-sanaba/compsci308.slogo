#Estimation: before looking at the old code:
###How long do you think it will take you to complete this new feature?
This addition should take my approximately an hour to complete. 
###How many files will you need to add or update? Why?
In order to add this view to the screen I will have to change the input panel. I have to pass in all turtles to the input panel now so that the input panel can modify any of them. The GUI class will have to be changed to pass in this list. The input panel will have to be changed to take this parameter. The input panel will have to be added so that my node for this new view will be included. Finally, I will have to make a class to create the node which will open the view of all turtles and the appropriate smaller classes to allow users to change the turtle image.
#Review: after completing the feature:
###How long did it take you to complete this new feature?
The new feature took me approximately 2 hours to implement. 
### How many files did you need to add or update? Why?
I changed 12 files. 7 of these were simply to create the new view. These included classes for the button to open the new stage, the class creating the new stage, the class for the buttons which change the turtle image, and various utility classes and interfaces. More importantly I also had to change preexisting files in terms of the properties file for button naming, the input panel for adding a new button. Additionally, I had to pass to the input panel a map of all the turtles rather than just one as my new view had to be able to change all of these. I had to turn this preexisting map into an observable for the purpose of the new view. Additionally, I had to also change the TurtleView class to contain an observable string so that the new view could always keep track of the current image path. Finally, I had to add a method to the turtle view manager in order to determine how many possible turtle images there are.
### Did you get it completely right on the first try? 
My general ideas were correct. Like I thought, I did have to change the GUI to pass in the map of all turtles, change the input panel to include the new button, and create all the classes need for the new views functionality. However, I did not consider how the view would get needed information.  At first I did not think about making the map of turtles observable so that my view could dynamically update. I did not consider that my TurtleView could not be observed to determine when the image changed, and I did not consider that I would have to add in a new public method to the turtle view manager in order to determine what possible images the turtle could be. 
#Analysis: what do you feel this exercise reveals about your project's design and documentation?
### Was it as good as you remembered?
If I did not do this exercise, I would have left the class thinking that Slogo may have been my high point in this class due to me liking my masterpiece so much. The exercise showed me that my code was pretty terrible. Throwing all GUI elements into one class made modification to preexisting classes neccessary and awkward. Originally, I thought I encapsulated the buttons from affecting the Turtle's directly, but now I see that any button could change a Turtle messing up what the backend believed was on screen. My abstract classes for display buttons were still very useful and allowed me to not have to rewrite a significant amount of code when creating a new button which changed turtles through the backend. 
###what could be improved?
My encapsulation was terrible and defeated the purpose of a lot of the work the team did in having a single channel for modifying turtles. This could be improved so that all front end objects cannot directly modify a turtle. Additionally, as I said in my slogo analysis, the majority of my GUI class should have been broken down into smaller classes. The class was so huge that it was unreadable not well documented, and hard to understand how certain elements were being placed on the screen. I realize that this lump of code  would have made it incredibly challenging for someone who was not me to add a new view. 
###What would it have been like if you were not familiar with the code at all?
My class names were very useful and it was clear that the inputpanel had the elements needed and that the GUI class created the input panel. I also think that through reading my code documentation it would have been feasible for someone to understand how to create a button and save a significant amount of code by extending certain abstract classes. However, the easiest ways to make the new view could easily break the visualization due to poor encapsulation and documenting with the GUI and input panel classes was poor enough that the only real way for another coder to see what to do would be through trial and error. 

Overall, the experience has shown me that just a month ago my overall understanding of encapsulation was incredibly subpar compared to where I am now. I also now realize how important it is to create smaller classes and avoid having something like my large GUI class of hard coded object locations. Finally, I realize that even though I did document almost all of my public methods. The references I made were challenging to understand and I should approach documentation with a better understanding of the perspective of whoever will read my code. 

